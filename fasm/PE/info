
95% исполняемых (exe, dll, драйверы(sys)) файлов — это PE формат файлов
По умолчанию код для этого формата 32-битный

Include=C:\Programms\fasmw\INCLUDE fasm hello.asm
Path=C:\Programms\fasmw

Запуск сборки (автоматическое определение формата)
$ fasm fasm.asm

Или указать целеой формат файла
    $ fasm hello.asm hello.exe
    $ fasm hello.asm hello.com

    $ file fasm
 fasm: PE32 executable (console) Intel 80386, for MS Windows


Структура программы ------------------------------------------------------

;Формат выходного файла
  `format PE gui`

;Точка входа
   entry start

;Подключаемые модули
   include 'win32a.inc'

;Секция кода
   section '.code' code readable executable
           start:
           ;код программы
;Секция данных
   section '.data' data readable
           ;Данные используемые программой

;Секция с таблицей импорта библиотек .dll и функций
section '.idata' import data readable writeable
        ;Таблица импорта

-------------------------------------------------------------------------

Формат выходного файла
`format PE64` - 64 разрядное приложение
`format PE GUI 4.0` - графическое (оконное) приложение
`format PE Console` - консольное приложение
`format PE Native`  - драйвера
`format PE DLL`     - DLL
|

• code     - секция кода;
• data     - секция данных;
• export   - секция экспорта;
• import   - секция импорта;
• resource - секция ресурсов.

• section '.code'  code (атрибуты) - исполняемый код;
• section '.data'  data (атрибуты) - инициал.данные (строки и переменные);
• section '.bss'   data (атрибуты) - неинициал.данные ('0' или '?');
• section '.idata' data (атрибуты) - импорт функций;
• section '.edata' data (атрибуты) - экспорт функций;
• section '.reloc' data (атрибуты) - правка ImageBase;
• section '.rsrc'  data (атрибуты) - ресурсы (иконки, курсоры и пр.);
• section '.tls'   data (атрибуты) - локальная память потока (Thread Local Storage);
• section '.rdata' data (атрибуты) - отладочная информация;
• section '.r71mt' data (атрибуты) - своя секция под барахло.

• readable    - секция доступна на чтение;
• writable    - секция доступна на запись;
• executable  - исполняемая секция;
• shareable   - расшаренная секция (вреда от которой больше, чем пользы);
• discardable - при ограниченной физ.памяти, это первый кандидат на выгрузку в своп;
• notpageable - из физ.памяти секцию сбрасывать нельзя!
• fixups      - авто/коррекция адресов и ошибок.

; Секция кода с атрибутами R/X (бит(x) от слова eXe).
section '.code' code readable executable

; Секция данных с атрибутами R/W.
section '.data' data readable writable

; Секция импорта с атрибутом только-чтение.
section '.idata' data import readable

; Секция релоков, которая авто-исправляет ошибки,
; и которую можно выгрузить из памяти после старта.
section '.reloc' data fixups discardable

; Собственная, открытая на R/W и шару секция,
; которую нельзя выгружать из памяти.
section '.r71mt' data readable writable shareable notpageable




|
Точка входа это адресс содержащий метку на первую команду для процессора
Благодаря меткам можно перемещаться по коду

entry start - обьявление метки
;код        - предварительный код
start:      - вызов метки старта
;код        - код программы
|
|
|
Подключаемые модули
Содержат константы и макросы
include '{fasm_path}\INCLUDE\ENCODING\WIN1251.INC'
|
|
|
Секция (имя меньше 8 символов не считая точки)
   `section 'имя' [индификатор] <флаги...>`
Логически разделяет код в зависимости от своего типа
    code - секция кода
    data - секция данных, резервирует данные для использования
    readable - секция, данных которые доступны для чтения
    writeable - секция, доступная для записи
    executable - секция, доступная на исполнение
    shareable - совместно используемая секция
    discardable - секция может быть выгружена из памяти
    notpageable - не подвергается страничному преобразованию

«section» определяет новую секцию
Возможные флаги такие: «code», «data», «readable», «writeable», «executable», «shareable», «discardable», «notpageable»
Специальные идентификатор «export», «import», «resource» и «fixups»
|
|
Флаги для секции data
    export - таблица экспорта
    import - таблица импорта
    resource - ресурсы

«data» начинает определение специальных данных PE, за директивой должен следовать один из идентификаторов данных
(«export», «import», «resource» или «fixups») или номер записи данных в заголовке PE и заканчиваться директивой «end data».
|
|
|
Таблица импорта
section '.import' import data readable writeable
    ;импортируемые библиотеки и псевдонимы для них
    ;попарно <псевдоним для обращения>,<имя библиотеки>\
     library kernel32, 'kernel32.dll', \
        user, 'USER32.DLL', \
        msvcrt, 'msvcrt.dll'

    ;импорт для каждой библиотеки отдельно
        ;<псевдоним  для обращения>\
        ;<псевдоним  для обращения>,<имя функции>

    ;импортируемые функции из kernel32.dll и псевдонимы для них
       import kernel32, \
       ExitProcess, 'ExitProcess'

    ;импортируемые функции из USER32.DLL и псевдонимы для них
      import user,\
        MessageBox, 'MessageBoxA'

    ;импортируемые функции из msvcrt.dll и псевдонимы для них
     import msvcrt, \
     printf, 'printf', \
     getchar,'_fgetchar'





«stack» устанавливает размер стека для PE, по умолчанию, равный 4096 байт
«heap» выбирает размер дополнительного места для PE,по умолчанию равным 65536 байт


Библиотеки
getchar - фиксирует окно в процессе
printf - печать в поток вывода
ExitProcess - завершение процесса
---------------------------------------------------------------

Системы счисления
Двоичная система 1010b
Шестнадцатиричная система FF6h

Хранение данных
- Регистры (общего пользования) `mov ebx,5`
- Память  `mov [адрес],5` (Копировать из памяти в память нельзя, используют промежуточное хранилище)
- Стек    `push 5`
- Файлы

Регистры общего пользования
 - EAX/AX/AH/AL (т.е. регистр EAX состоит из регистров AX/AH/AL где (младшее слово AX (Старший байт AH и Младший байт AL))
 - EBX/BX/BH/BL
 - EDX/DX/DH/DL
 - ECX/CX/CH/CL
 - ESI/SI
 - EDI/DI

16-разрядные регистры (AX, BX, CX, DX, SI, BP, DI, SP)

EAX Регистр 4 байта (32 бита) состоит из старшего слова 2 байта и младшего слова AX 2 байта (16 бит)
Младшее слово AX состоит из 2 байт Старший байт AH 8 бит и Младший байт AL  8 бит.
Регистры связаны если поменять младшее слово то поменяется и старшее слово.


Память
Побайтная адресация, т.е. у каждого байта памяти есть адрес
Размер адреса двойное слово 00000000h
    lea eax,[метка+1] ; поместить в регистр eax адрес значение, лежащего по адресу метка+1
    mov [ebx],eax ; запись в память значение которой хранится в регистре ebx
    mov [value],eax ; запись в память значение которой хранится в value
    mov ebx,eax ; запись в сам регистр ebx
    mov [ebx],[eax] ; так делать запрещенно из памяти в память, нужно промежуточное хранилище


 Стек
 Размер данных в стеке 4 байта
 Память в области процесса, последний пришел - первым вышел

     pop <источник> - Извлечь из стека значение
     popa/popad     - Восстановить из стека регистры
     popf/popfd     - Восстановить из стека регистры флагов
     push <источник> - Поместить какое-то значение в стек
     pusha/pushad   - Поместить в стек значения регистров
     pushf/pushfd   - Поместить в стек значение регистра флагов

Если в регистр младшее слово 2 байта BX записать данные из стека то старшие байты будут потерены
т.е. из 32 бит останутся только последние 16 бит


=============================================================================================
Обьявление и резервирование данных

Обьявление   Размер (байты)    Резервирование (?)
  данных       ячейки данных      места
db,file             1              Rb
du,dw               2              Rw
dd                  4              rd (для чисел 1 rd =  −2147483648 +2147483647, для строк 4 символа)
dp                  6              rp
df                  6              rf
dq                  8              rq
dt                  10             rt

Пример использования в секции data
    section '.data' data readable writeable
        metkaStr db 'Hello World!', 0


Размеры операторов
Оператор	Биты	Байты
byte	     8   	1
word	    16  	2
dword	    32  	4
fword	    48  	6
pword	    48	    6
qword	    64  	8
tbyte	    80  	10
qword	    80  	10
dqword	    128	    16

Пример использования в секции code. Явное обьявление размера
    section '.code' code readable executable
        mov [eax], word 50
        mov ebx, word [eax]


Вычисление адреса, размер адреса это двойное слово dd
Множитель должен быть степенью двойки
    mov eax, dword [ebx+4*ebx]
    mov eax, dword [ebx+2]


Поменять местами данные, между регистрами или ячейками памяти
    xchg операд1, операнд2


=============================================================================================
Метки
 - реализовать циклы
 - условные конструкции
 - обращаться к данным
 - задавать точку входа в программу

    Метка содержит в себе адрес на команду, которая идет сразу после метки.
    Когда мы задаем переход к метке мы, по сути, даем процессору команду перейти к новому адресу,
    с которого продолжится выполнение программы

    Цикл while
        metka:
            ;код
            cmp операнд1,операнд2
            je metka
            ;код

=============================================================================================
Указатель
Адрес в памяти по которому хранятся данные
Поддерживают операции такие же как и целые числа
После компиляции метки заменяются на указатели на эти данные

    Получение адреса
        lea регистр,[метка] ; lea считыет выражение из скобок

=============================================================================================
Константы (разме dword 4 байта)
  MYVALUE = 5

В библиотеки kernel32.inc обьявлены константы TRUE = 1 и FALSE = 0

=============================================================================================

Операции inc, dec, sub, mul, neg
Инкремент:
inc eax
inc byte [address]

Декремент:
dec eax
dec byte [address]

Меняет знак умножая на -1
neg операнд
neg eax

Сложение
(не сложит две ячейки памяти)
add операнд1, операнд2 ; результат сохраняется в операнд1
add dword [address],eax
add [address],44
add eax,ebx
add eax,3

Сложение с изменением флага переполнения CF
(в случае переполнения типа флаг CF=1 иначе CF=0)
adc операнд1, операнд2 ; результат сохраняется в операнд1


Вычитание
если старший бит 1 то отрицательное число
если старший бит 0 то положительное число
sub операнд1, операнд2 ; результат сохраняется в операнд1
sub dword [address],eax
sub [address],44
sub eax,ebx
sub eax,3


Умножение
mul для умножения чисел без знака
imul для умножения чисел со знаком
    Умножение [address_A] * [address_B]
    mov eax,[address_A] ; переместить в регистр первый операнд умножения
    mul [address_B] ; передать множитель

Для умножения mul результат в регистрах
Размер операндов:  Множитель:  Результат в:
byte                al         ax
word                ax         dx:ax   ; старшая часть в dx, младшая в ax
dword               eax        edx:eax ; старшая часть в edx, младшая в eax

Для умножения чисел со знаком результат в левом операнде
Сдвиг влево равносилен умножению на два


Деление
div для деления чисел без знака
idiv для деления чисел со знаком
     ;деление [address] / eac
     mov eax,[address]
     div eac

Размер операндов:  Делимое:  Частное:   Остаток:
byte                ax         al          ah
word                dx:ax      ax          dx
dword               edx:eax    eax         edx

Сдвиг вправо равносилен делению на два
=============================================================================================

Сравнение
Сравнивает два числовых источника
назначение - регистр либо память
источник - константы, регистр, память
    cmp назначение, источник

Пример сравнение и переходов
    cmp eax,5
    je equal      - Если операнды раны (т.е. когда предыдущая операция дала результат 0 , 1-1=0 тоже сработатет) то переход в инструкцию je или jz
    nop
    jne not_equal -  Если операнды не раны то переход в инструкцию jne или jnz
    nop
    jg greated    -  Если левый операнд больше правого jg
    nop
    jl lower      -  Если левый операнд меньше правого jl
    nop
    jnl not_lower  -  Если левый операнд не меньше правого jnl или jge
    nop
    jng not_greated -  Если левый операнд не больше правого jng или jle
    nop
    jmp equal - Безусловный переход

    equal:
        nop
    greated:
        nop
    lower:
        nop
    not_lower:
        nop
    not_greated:
        nop

==========================================================================

Логические операции
and, or, xor, not, test

Все логические команды выполняются над битами поразрядно
операнд1 это регистр либо память
операнд2 это костанта,регистр, память

xor  - 0 это когда два операнда одинаковые и 1 если они разные
       Обнуляют регистр `xor eax,eax`

not - меняет 0 на 1 и 1 на 0

Команда test
Результат не записывается, аналогична and.
Изменяет значение флагов ZF,SF,PF
Всегда сбрасывает флаги OF (переполнение),CF (переноса)

операнд1 операнд2  or  and  xor  not
0        0          0   0   0     1
0        1          1   0   1     1
1        0          1   0   1     0
1        1          1   1   0     0

==========================================================================
Вещественное число
https://v2.repetitors.info/library.php?sposoby_perevoda_chisel#:~:text=%D0%94%D0%BB%D1%8F%20%D0%BF%D0%B5%D1%80%D0%B5%D0%B2%D0%BE%D0%B4%D0%B0%20%D0%BE%D1%82%D1%80%D0%B8%D1%86%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D0%B3%D0%BE%20%D1%87%D0%B8%D1%81%D0%BB%D0%B0%20%D0%B2,%D0%B7%D0%B0%D0%B9%D0%BC%D1%91%D1%82%20%D1%83%20%D0%BD%D0%B0%D1%81%20%D0%BE%D0%B4%D0%B8%D0%BD%20%D0%B1%D0%B0%D0%B9%D1%82.
https://www.youtube.com/watch?v=JXd7ZO3C-Tc&t=281s&ab_channel=TempestaTorres

0.0155625 = 1.55625 * 10^-2
155.625 = 1.55625 * 10^2 => мантиса нормализованна
155.625 = 0.155625 * 10^3 => мантиса денормализованна

2 - порядок смещения точки
10 - основание системы исчисления
10^2 - экспонета
1.55625 - мантиса

Нормализованное число
1 <= мантиса < 10

Денормализованное число
0.1 <= мантиса <1



Перевод из двоичной в десятичную 8 байтное знаковое число (-128 - 127)
 Десятичная система 6n*(10^n-1)
     125 = 1*(1*10^2) + 2*(10^1) + 5*(10^0) = 100 + 20 + 5
 Двоичная система  1n*(2^n-1)
     1111101 = 1*(2^6) + 1*(2^5) + 1*(2^4) + 1*(2^3) + 1*(2^2) + 0*(2^1) + 1*(2^0) = 64+32+16+8+4+0+1 = 125
 Разложим 125
         125/2 = 62, остаток 1
         62/2  = 31, остаток 0
         31/2  = 15, остаток 1
         15/2  = 7,  остаток 1
         7/2   = 3,  остаток 1
         3/2   = 1,  остаток 1
         1/2   = 0,  остаток 1
        Итог собрать с конца: 1111101
И добавить до размера 8 байт: 01111101


Перевод отрицательных чисел
Здесь нужно учесть, что число будет представлено в дополнительном коде.
Для перевода числа в дополнительный код нужно знать конечный размер числа, то есть во что мы хотим его вписать — в байт, в два байта, в четыре.
Старший разряд числа означает знак. Если там 0, то число положительное, если 1, то отрицательное.
Перевод числа со знаком в двоичную систему:
    Для перевода отрицательного числа в двоичный дополнительный код нужно
    - перевести положительное число в двоичную систему
    - потом поменять нули на единицы и единицы на нули
    - затем прибавить к результату 1

    Для -125
       положительное в двоичной:  01111101
       реверс                  :  10000010
       прибавить 1             :  10000011 (Прибавление 1 к 10011 => 10100)


Перевод дробных чисел десятичных в двоичную систему
 При помощи последовательного умножения на новое основание с собиранием целых частей.


